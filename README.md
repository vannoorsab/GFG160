# GFG160 - Data Structures and Algorithms (DSA) Solutions

Welcome to the **GFG160** repository! This repository contains my solutions to the problems from the **GFG160** series, aimed at improving problem-solving skills in Data Structures and Algorithms (DSA).

## Table of Contents

- [About GFG160](#about-gfg160)
- [Problem Solving Approach](#problem-solving-approach)
- [Solutions Overview](#solutions-overview)
- [Technologies Used](#technologies-used)
- [Contributing](#contributing)
- [License](#license)

## About GFG160

The **GFG160** series consists of 160 problems focusing on fundamental Data Structures and Algorithms. This series is designed to strengthen problem-solving skills for programmers of all levels, especially in preparation for coding interviews.

## Problem Solving Approach

For each problem in the **GFG160** series, I have followed these steps:

1. **Understand the Problem Statement**: Carefully read and understand the requirements of each problem.
2. **Break Down the Problem**: Analyze the problem, break it into smaller sub-problems, and consider edge cases.
3. **Choose Data Structures**: Depending on the problem, choose the most appropriate data structure (e.g., arrays, hash maps, stacks).
4. **Optimize the Solution**: Implement the solution with a focus on time and space efficiency.
5. **Testing**: Run the solution with various test cases to ensure correctness.

## Solutions Overview

Here are the problems I've solved so far in the **GFG160** series:

### Day 1: **Second Largest Element**
- **Problem Statement**: Find the second largest element in an array.
- **Approach**: Used a `TreeSet` to store unique elements and easily find the second largest by removing the largest element.

### Day 2: **Move All Zeroes to End**
- **Problem Statement**: Move all zeroes in the array to the end without changing the order of non-zero elements.
- **Approach**: Used a two-pointer technique to rearrange the elements in-place.

### Day 3: **Reverse an Array**
- **Problem Statement**: Reverse the elements of an array in place.
- **Approach**: Used a simple loop with two pointers (one at the start and one at the end) to reverse the array.

### Day 4: **Rotate Array**
- **Problem Statement**: Rotate the elements of the array by `k` positions to the right.
- **Approach**: Used array slicing and in-place rotation to efficiently rotate the array.

### Day 5: **Next Permutation**
- **Problem Statement**: Find the next lexicographically greater permutation of the array.
- **Approach**: Used the algorithm for finding the next permutation in-place with the next greater element technique.

### Day 6: **Majority Element**
- **Problem Statement**: Find the element that appears more than `n/2` times in the array (if any).
- **Approach**: Implemented the Boyer-Moore Voting Algorithm for an efficient O(n) solution.

---

## Technologies Used

- **Java**: The primary programming language used to solve the problems.
- **Data Structures**: Arrays, HashMaps, TreeSets, etc.
- **Algorithms**: Sorting, Searching, Greedy, Two Pointer, and Voting algorithms.
